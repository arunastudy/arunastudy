<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aruna — Мини-игра (Jump)</title>
  <style>
    /* Простая стилизация: градиент фона, плавные переходы */
    :root {
      --bg1: #7F00FF;
      --bg2: #E100FF;
    }
    html,body { height:100%; margin:0; font-family:Inter, system-ui, -apple-system, sans-serif; background: linear-gradient(135deg,var(--bg1),var(--bg2)); display:flex; align-items:center; justify-content:center; }
    #game { width:min(720px,92vw); height:420px; background: rgba(255,255,255,0.06); border-radius:14px; box-shadow:0 8px 40px rgba(0,0,0,0.35); overflow:hidden; position:relative; }
    canvas { display:block; width:100%; height:100%; }
    .ui { position:absolute; left:16px; top:16px; color:white; font-weight:600; text-shadow:0 2px 6px rgba(0,0,0,0.6);}
    .hint { position:absolute; right:16px; bottom:16px; color:#fff; opacity:0.9; font-size:13px; }
    .btn { position:absolute; right:16px; top:16px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.06); color:white; padding:6px 10px; border-radius:8px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c"></canvas>
    <div class="ui" id="score">Score: 0</div>
    <button class="btn" id="restart">Restart</button>
    <div class="hint">Space / Click — прыгнуть</div>
  </div>

  <script>
    // Очень простая canvas-игра: "прыгающий персонаж" избегает препятствий.
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    function resize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * devicePixelRatio;
      canvas.height = rect.height * devicePixelRatio;
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Игровые переменные
    let player = { x:50, y:300, w:32, h:32, vy:0, gravity:0.9, jump:-14, grounded:false };
    let obstacles = [];
    let speed = 4;
    let spawnTimer = 0;
    let score = 0;
    let running = true;

    const scoreEl = document.getElementById('score');
    document.getElementById('restart').addEventListener('click', init);

    function init() {
      player.y = 300; player.vy = 0;
      obstacles = [];
      spawnTimer = 0; score = 0; running = true; speed = 4;
      scoreEl.textContent = 'Score: 0';
    }
    init();

    // input
    function jump() {
      if (player.y >= 300) {
        player.vy = player.jump;
      }
    }
    window.addEventListener('keydown', e => { if (e.code === 'Space') { jump(); } });
    window.addEventListener('pointerdown', jump);

    function spawnObstacle() {
      const h = 40 + Math.random() * 60;
      obstacles.push({ x: (canvas.width / devicePixelRatio) + 20, y: 360 - h, w: 28 + Math.random()*40, h: h });
    }

    function update() {
      if (!running) return;
      // player physics
      player.vy += player.gravity;
      player.y += player.vy;
      if (player.y > 300) { player.y = 300; player.vy = 0; }

      // spawn
      spawnTimer++;
      if (spawnTimer > 90 - Math.min(score, 50)) {
        spawnObstacle();
        spawnTimer = 0;
      }

      // move obstacles
      for (let i = obstacles.length-1; i >=0; i--) {
        obstacles[i].x -= speed;
        if (obstacles[i].x + obstacles[i].w < -50) {
          obstacles.splice(i,1);
          score++;
          speed += 0.02;
          scoreEl.textContent = 'Score: ' + score;
        }
      }

      // collision
      for (let obs of obstacles) {
        if (player.x < obs.x + obs.w && player.x + player.w > obs.x &&
            player.y < obs.y + obs.h && player.y + player.h > obs.y) {
          running = false;
        }
      }
    }

    function draw() {
      const w = canvas.width / devicePixelRatio;
      const h = canvas.height / devicePixelRatio;
      // background
      ctx.clearRect(0,0,w,h);
      // ground gradient
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'rgba(255,255,255,0.03)');
      g.addColorStop(1,'rgba(255,255,255,0.02)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // ground line
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(0,360,w,6);

      // player
      const grad = ctx.createLinearGradient(player.x, player.y, player.x+player.w, player.y+player.h);
      grad.addColorStop(0,'#FFD43B');
      grad.addColorStop(1,'#FF7A59');
      ctx.fillStyle = grad;
      ctx.fillRect(player.x, player.y - player.h, player.w, player.h);
      // eyes (simple)
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(player.x+6, player.y - player.h + 8, 4,4);
      ctx.fillRect(player.x+20, player.y - player.h + 8, 4,4);

      // obstacles
      for (let obs of obstacles) {
        const g2 = ctx.createLinearGradient(obs.x, obs.y, obs.x+obs.w, obs.y+obs.h);
        g2.addColorStop(0,'rgba(255,255,255,0.1)');
        g2.addColorStop(1,'rgba(255,255,255,0.04)');
        ctx.fillStyle = g2;
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      }

      // if game over
      if (!running) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,w,h);
        ctx.fillStyle = 'white';
        ctx.font = '28px Inter, system-ui, -apple-system';
        ctx.fillText('Game Over — нажми Restart', 60, h/2 - 10);
        ctx.font = '20px Inter, system-ui';
        ctx.fillText('Набрано очков: ' + score, 60, h/2 + 28);
      }
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
